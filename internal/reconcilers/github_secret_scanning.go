//
// Copyright 2023 Stacklok, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package events provides implementations of all the event handlers
// the GitHub provider supports.

// Package reconcilers provides implementations of all the reconcilers
package reconcilers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/ThreeDotsLabs/watermill/message"
	github "github.com/google/go-github/v53/github"

	"github.com/stacklok/mediator/pkg/controlplane"
	"github.com/stacklok/mediator/pkg/db"
	ghclient "github.com/stacklok/mediator/pkg/providers/github"
)

// code generated by
// gojsonschema -p reconcilers pkg/controlplane/policy_types/github/secret_scanning/1.0.0/schema.json

// SecretScanningSchemaJson is the JSON schema for the SecretScanning event
type SecretScanningSchemaJson struct {
	// SecretScanningEnabled corresponds to the JSON schema field
	// "secret_scanning_enabled".
	SecretScanningEnabled bool `json:"secret_scanning_enabled" yaml:"secret_scanning_enabled" mapstructure:"secret_scanning_enabled"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecretScanningSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SecretScanningSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["secret_scanning_enabled"]; !ok || v == nil {
		plain.SecretScanningEnabled = true
	}
	*j = SecretScanningSchemaJson(plain)
	return nil
}

// SecurityAndAnalysisEvent is the event type for the SecurityAndAnalysis event
// We need to maintain this here for now since it's not available in
// the go-github library.
// Note that we don't include the changes here since we'll rely on the
// reconciler to fetch the latest state of the repository
type SecurityAndAnalysisEvent struct {
	Action       *string              `json:"action,omitempty"`
	Repo         *github.Repository   `json:"repository,omitempty"`
	Org          *github.Organization `json:"organization,omitempty"`
	Sender       *github.User         `json:"sender,omitempty"`
	Installation *github.Installation `json:"installation,omitempty"`
}

// ParseSecretScanningEventGithub parses a branch protection event from GitHub
func ParseSecretScanningEventGithub(ctx context.Context, store db.Store, msg *message.Message) error {
	var event SecurityAndAnalysisEvent

	if err := json.Unmarshal([]byte(msg.Payload), &event); err != nil {
		return fmt.Errorf("failed to unmarshal security and analysis event: %w", err)
	}

	if event.Repo == nil {
		return fmt.Errorf("security and analysis event missing repo")
	}

	repoID := int32(*event.Repo.ID)

	policies, err := store.GetPoliciesByRepoAndType(ctx, db.GetPoliciesByRepoAndTypeParams{
		Provider: ghclient.Github, PolicyType: "secret_scanning", RepoID: repoID})
	if err != nil {
		return fmt.Errorf("failed to get policies for repo %d: %w", repoID, err)
	}

	if len(policies) == 0 {
		log.Printf("No secret scanning policies for %s/%s", *event.Repo.Owner.Login, *event.Repo.Name)
		return nil
	}

	// reconcile secret scanning
	for _, policy := range policies {
		repo, err := getRepoState(ctx, store, policy.GroupID, *event.Repo.Owner.Login, *event.Repo.Name)
		if err != nil {
			return fmt.Errorf("failed to get repo state for %s: %w", *event.Repo.FullName, err)
		}

		var policyData SecretScanningSchemaJson
		err = policyData.UnmarshalJSON(policy.PolicyDefinition)
		if err != nil {
			return err
		}

		st := repo.SecurityAndAnalysis.SecretScanning.GetStatus()
		actualStatus := st == "enabled"
		if actualStatus != policyData.SecretScanningEnabled {
			// TODO: Emit event here and issue a warning
			log.Printf("Secret scanning status for %s/%s is %t, but policy is %t",
				*event.Repo.Owner.Login, *event.Repo.Name, actualStatus, policyData.SecretScanningEnabled)
			// No need to continue
			return nil
		}

		log.Printf("Secret scanning status for %s/%s is passing the policy check", *event.Repo.Owner.Login, *event.Repo.Name)
	}

	return nil
}

func getRepoState(ctx context.Context, store db.Store, groupID int32, owner, repo string) (*github.Repository, error) {
	// Populate the database with the repositories using the GraphQL API
	token, err := controlplane.GetProviderAccessToken(ctx, store, ghclient.Github, groupID, false)
	if err != nil {
		return nil, err
	}
	client, err := ghclient.NewRestClient(ctx, ghclient.GitHubConfig{
		Token: token.AccessToken,
	})
	if err != nil {
		return nil, err
	}

	repoInfo, err := client.GetRepository(ctx, owner, repo)
	if err != nil {
		return nil, fmt.Errorf("failed to get repository %s/%s: %w", owner, repo, err)
	}

	return repoInfo, nil
}
