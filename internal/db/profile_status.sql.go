// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: profile_status.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRuleEvaluationStatusForRepository = `-- name: CreateRuleEvaluationStatusForRepository :exec
INSERT INTO rule_evaluation_status (
    profile_id,
    repository_id,
    rule_type_id,
    entity,
    eval_status,
    eval_details,
    last_updated
) VALUES ($1, $2, $3, 'repository', $4, $5, NOW())
`

type CreateRuleEvaluationStatusForRepositoryParams struct {
	ProfileID    uuid.UUID       `json:"profile_id"`
	RepositoryID uuid.NullUUID   `json:"repository_id"`
	RuleTypeID   uuid.UUID       `json:"rule_type_id"`
	EvalStatus   EvalStatusTypes `json:"eval_status"`
	EvalDetails  string          `json:"eval_details"`
}

func (q *Queries) CreateRuleEvaluationStatusForRepository(ctx context.Context, arg CreateRuleEvaluationStatusForRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, createRuleEvaluationStatusForRepository,
		arg.ProfileID,
		arg.RepositoryID,
		arg.RuleTypeID,
		arg.EvalStatus,
		arg.EvalDetails,
	)
	return err
}

const getProfileStatusByIdAndProject = `-- name: GetProfileStatusByIdAndProject :one
SELECT p.id, p.name, ps.profile_status, ps.last_updated FROM profile_status ps
INNER JOIN profiles p ON p.id = ps.profile_id
WHERE p.id = $1 AND p.project_id = $2
`

type GetProfileStatusByIdAndProjectParams struct {
	ID        uuid.UUID `json:"id"`
	ProjectID uuid.UUID `json:"project_id"`
}

type GetProfileStatusByIdAndProjectRow struct {
	ID            uuid.UUID       `json:"id"`
	Name          string          `json:"name"`
	ProfileStatus EvalStatusTypes `json:"profile_status"`
	LastUpdated   time.Time       `json:"last_updated"`
}

func (q *Queries) GetProfileStatusByIdAndProject(ctx context.Context, arg GetProfileStatusByIdAndProjectParams) (GetProfileStatusByIdAndProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileStatusByIdAndProject, arg.ID, arg.ProjectID)
	var i GetProfileStatusByIdAndProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProfileStatus,
		&i.LastUpdated,
	)
	return i, err
}

const getProfileStatusByNameAndProject = `-- name: GetProfileStatusByNameAndProject :one
SELECT p.id, p.name, ps.profile_status, ps.last_updated FROM profile_status ps
INNER JOIN profiles p ON p.id = ps.profile_id
WHERE p.name = $1 AND p.project_id = $2
`

type GetProfileStatusByNameAndProjectParams struct {
	Name      string    `json:"name"`
	ProjectID uuid.UUID `json:"project_id"`
}

type GetProfileStatusByNameAndProjectRow struct {
	ID            uuid.UUID       `json:"id"`
	Name          string          `json:"name"`
	ProfileStatus EvalStatusTypes `json:"profile_status"`
	LastUpdated   time.Time       `json:"last_updated"`
}

func (q *Queries) GetProfileStatusByNameAndProject(ctx context.Context, arg GetProfileStatusByNameAndProjectParams) (GetProfileStatusByNameAndProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileStatusByNameAndProject, arg.Name, arg.ProjectID)
	var i GetProfileStatusByNameAndProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProfileStatus,
		&i.LastUpdated,
	)
	return i, err
}

const getProfileStatusByProject = `-- name: GetProfileStatusByProject :many
SELECT p.id, p.name, ps.profile_status, ps.last_updated FROM profile_status ps
INNER JOIN profiles p ON p.id = ps.profile_id
WHERE p.project_id = $1
`

type GetProfileStatusByProjectRow struct {
	ID            uuid.UUID       `json:"id"`
	Name          string          `json:"name"`
	ProfileStatus EvalStatusTypes `json:"profile_status"`
	LastUpdated   time.Time       `json:"last_updated"`
}

func (q *Queries) GetProfileStatusByProject(ctx context.Context, projectID uuid.UUID) ([]GetProfileStatusByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfileStatusByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProfileStatusByProjectRow{}
	for rows.Next() {
		var i GetProfileStatusByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProfileStatus,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRuleEvaluationStatusByProfileId = `-- name: ListRuleEvaluationStatusByProfileId :many
SELECT res.eval_status as eval_status, res.eval_last_updated as eval_last_updated, res.eval_details as eval_details, res.remediation_status as rem_status, res.remediation_details as rem_details, res.remediation_last_updated as rem_last_updated, res.repository_id as repository_id, res.entity as entity, repo.repo_name as repo_name, repo.repo_owner as repo_owner, repo.provider as provider, rt.name as rule_type_name, rt.id as rule_type_id
FROM rule_evaluation_status res
INNER JOIN repositories repo ON repo.id = res.repository_id
INNER JOIN rule_type rt ON rt.id = res.rule_type_id
WHERE res.profile_id = $1 AND
    (
        CASE
            WHEN $2::entities = 'repository' AND res.repository_id = $3::UUID THEN true
            WHEN $2::entities  = 'artifact' AND res.artifact_id = $3::UUID THEN true
            WHEN $3::UUID IS NULL THEN true
            ELSE false
        END
    ) AND (rt.name = $4 OR $4 IS NULL)
`

type ListRuleEvaluationStatusByProfileIdParams struct {
	ProfileID  uuid.UUID      `json:"profile_id"`
	EntityType NullEntities   `json:"entity_type"`
	EntityID   uuid.NullUUID  `json:"entity_id"`
	RuleName   sql.NullString `json:"rule_name"`
}

type ListRuleEvaluationStatusByProfileIdRow struct {
	EvalStatus      EvalStatusTypes        `json:"eval_status"`
	EvalLastUpdated time.Time              `json:"eval_last_updated"`
	EvalDetails     string                 `json:"eval_details"`
	RemStatus       RemediationStatusTypes `json:"rem_status"`
	RemDetails      string                 `json:"rem_details"`
	RemLastUpdated  sql.NullTime           `json:"rem_last_updated"`
	RepositoryID    uuid.NullUUID          `json:"repository_id"`
	Entity          Entities               `json:"entity"`
	RepoName        string                 `json:"repo_name"`
	RepoOwner       string                 `json:"repo_owner"`
	Provider        string                 `json:"provider"`
	RuleTypeName    string                 `json:"rule_type_name"`
	RuleTypeID      uuid.UUID              `json:"rule_type_id"`
}

func (q *Queries) ListRuleEvaluationStatusByProfileId(ctx context.Context, arg ListRuleEvaluationStatusByProfileIdParams) ([]ListRuleEvaluationStatusByProfileIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listRuleEvaluationStatusByProfileId,
		arg.ProfileID,
		arg.EntityType,
		arg.EntityID,
		arg.RuleName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRuleEvaluationStatusByProfileIdRow{}
	for rows.Next() {
		var i ListRuleEvaluationStatusByProfileIdRow
		if err := rows.Scan(
			&i.EvalStatus,
			&i.EvalLastUpdated,
			&i.EvalDetails,
			&i.RemStatus,
			&i.RemDetails,
			&i.RemLastUpdated,
			&i.RepositoryID,
			&i.Entity,
			&i.RepoName,
			&i.RepoOwner,
			&i.Provider,
			&i.RuleTypeName,
			&i.RuleTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRuleEvaluationStatusForRepository = `-- name: UpdateRuleEvaluationStatusForRepository :exec
UPDATE rule_evaluation_status 
    SET eval_status = $1, eval_details = $2, remediation_status = $3, remediation_details=$4, remediation_last_updated=$5, last_updated = NOW()
    WHERE id = $5
`

type UpdateRuleEvaluationStatusForRepositoryParams struct {
	EvalStatus             EvalStatusTypes        `json:"eval_status"`
	EvalDetails            string                 `json:"eval_details"`
	RemediationStatus      RemediationStatusTypes `json:"remediation_status"`
	RemediationDetails     string                 `json:"remediation_details"`
	RemediationLastUpdated sql.NullTime           `json:"remediation_last_updated"`
}

func (q *Queries) UpdateRuleEvaluationStatusForRepository(ctx context.Context, arg UpdateRuleEvaluationStatusForRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, updateRuleEvaluationStatusForRepository,
		arg.EvalStatus,
		arg.EvalDetails,
		arg.RemediationStatus,
		arg.RemediationDetails,
		arg.RemediationLastUpdated,
	)
	return err
}

const upsertRuleEvaluationStatus = `-- name: UpsertRuleEvaluationStatus :exec
INSERT INTO rule_evaluation_status (
    profile_id,
    repository_id,
    artifact_id,
    rule_type_id,
    entity,
    eval_status,
    eval_details,
    remediation_status,
    remediation_details,
    remediation_last_updated,
    eval_last_updated
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
ON CONFLICT(profile_id, repository_id, COALESCE(artifact_id, '00000000-0000-0000-0000-000000000000'::UUID), entity, rule_type_id) DO UPDATE SET
    eval_status = $6,
    eval_details = $7,
    remediation_status = $8,
    remediation_details = $9,
    remediation_last_updated = COALESCE($10, rule_evaluation_status.remediation_last_updated), -- don't overwrite timestamp already set with NULL
    eval_last_updated = NOW()
WHERE rule_evaluation_status.profile_id = $1
  AND rule_evaluation_status.repository_id = $2
  AND rule_evaluation_status.artifact_id IS NOT DISTINCT FROM $3
  AND rule_evaluation_status.rule_type_id = $4
  AND rule_evaluation_status.entity = $5
`

type UpsertRuleEvaluationStatusParams struct {
	ProfileID              uuid.UUID              `json:"profile_id"`
	RepositoryID           uuid.NullUUID          `json:"repository_id"`
	ArtifactID             uuid.NullUUID          `json:"artifact_id"`
	RuleTypeID             uuid.UUID              `json:"rule_type_id"`
	Entity                 Entities               `json:"entity"`
	EvalStatus             EvalStatusTypes        `json:"eval_status"`
	EvalDetails            string                 `json:"eval_details"`
	RemediationStatus      RemediationStatusTypes `json:"remediation_status"`
	RemediationDetails     string                 `json:"remediation_details"`
	RemediationLastUpdated sql.NullTime           `json:"remediation_last_updated"`
}

func (q *Queries) UpsertRuleEvaluationStatus(ctx context.Context, arg UpsertRuleEvaluationStatusParams) error {
	_, err := q.db.ExecContext(ctx, upsertRuleEvaluationStatus,
		arg.ProfileID,
		arg.RepositoryID,
		arg.ArtifactID,
		arg.RuleTypeID,
		arg.Entity,
		arg.EvalStatus,
		arg.EvalDetails,
		arg.RemediationStatus,
		arg.RemediationDetails,
		arg.RemediationLastUpdated,
	)
	return err
}
