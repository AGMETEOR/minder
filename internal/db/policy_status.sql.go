// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: policy_status.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRuleEvaluationStatusForRepository = `-- name: CreateRuleEvaluationStatusForRepository :exec
INSERT INTO rule_evaluation_status (
    policy_id,
    repository_id,
    rule_type_id,
    entity,
    eval_status,
    details,
    last_updated
) VALUES ($1, $2, $3, 'repository', $4, $5, NOW())
`

type CreateRuleEvaluationStatusForRepositoryParams struct {
	PolicyID     uuid.UUID       `json:"policy_id"`
	RepositoryID uuid.NullUUID   `json:"repository_id"`
	RuleTypeID   uuid.UUID       `json:"rule_type_id"`
	EvalStatus   EvalStatusTypes `json:"eval_status"`
	Details      string          `json:"details"`
}

func (q *Queries) CreateRuleEvaluationStatusForRepository(ctx context.Context, arg CreateRuleEvaluationStatusForRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, createRuleEvaluationStatusForRepository,
		arg.PolicyID,
		arg.RepositoryID,
		arg.RuleTypeID,
		arg.EvalStatus,
		arg.Details,
	)
	return err
}

const getPolicyStatusByIdAndProject = `-- name: GetPolicyStatusByIdAndProject :one
SELECT p.id, p.name, ps.policy_status, ps.last_updated FROM policy_status ps
INNER JOIN policies p ON p.id = ps.policy_id
WHERE p.id = $1 AND p.project_id = $2
`

type GetPolicyStatusByIdAndProjectParams struct {
	ID        uuid.UUID `json:"id"`
	ProjectID uuid.UUID `json:"project_id"`
}

type GetPolicyStatusByIdAndProjectRow struct {
	ID           uuid.UUID       `json:"id"`
	Name         string          `json:"name"`
	PolicyStatus EvalStatusTypes `json:"policy_status"`
	LastUpdated  time.Time       `json:"last_updated"`
}

func (q *Queries) GetPolicyStatusByIdAndProject(ctx context.Context, arg GetPolicyStatusByIdAndProjectParams) (GetPolicyStatusByIdAndProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getPolicyStatusByIdAndProject, arg.ID, arg.ProjectID)
	var i GetPolicyStatusByIdAndProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PolicyStatus,
		&i.LastUpdated,
	)
	return i, err
}

const getPolicyStatusByProject = `-- name: GetPolicyStatusByProject :many
SELECT p.id, p.name, ps.policy_status, ps.last_updated FROM policy_status ps
INNER JOIN policies p ON p.id = ps.policy_id
WHERE p.project_id = $1
`

type GetPolicyStatusByProjectRow struct {
	ID           uuid.UUID       `json:"id"`
	Name         string          `json:"name"`
	PolicyStatus EvalStatusTypes `json:"policy_status"`
	LastUpdated  time.Time       `json:"last_updated"`
}

func (q *Queries) GetPolicyStatusByProject(ctx context.Context, projectID uuid.UUID) ([]GetPolicyStatusByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getPolicyStatusByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPolicyStatusByProjectRow{}
	for rows.Next() {
		var i GetPolicyStatusByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PolicyStatus,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRuleEvaluationStatusByPolicyId = `-- name: ListRuleEvaluationStatusByPolicyId :many
SELECT res.eval_status as eval_status, res.last_updated as last_updated, res.details as details, res.repository_id as repository_id, res.entity as entity, repo.repo_name as repo_name, repo.repo_owner as repo_owner, repo.provider as provider, rt.name as rule_type_name, rt.id as rule_type_id
FROM rule_evaluation_status res
INNER JOIN repositories repo ON repo.id = res.repository_id
INNER JOIN rule_type rt ON rt.id = res.rule_type_id
WHERE res.policy_id = $1 AND
    (
        CASE
            WHEN $2::entities = 'repository' AND res.repository_id = $3::UUID THEN true
            WHEN $2::entities  = 'artifact' AND res.artifact_id = $3::UUID THEN true
            WHEN $3::UUID IS NULL THEN true
            ELSE false
        END
    ) AND (rt.name = $4 OR $4 IS NULL)
`

type ListRuleEvaluationStatusByPolicyIdParams struct {
	PolicyID   uuid.UUID      `json:"policy_id"`
	EntityType NullEntities   `json:"entity_type"`
	EntityID   uuid.NullUUID  `json:"entity_id"`
	RuleName   sql.NullString `json:"rule_name"`
}

type ListRuleEvaluationStatusByPolicyIdRow struct {
	EvalStatus   EvalStatusTypes `json:"eval_status"`
	LastUpdated  time.Time       `json:"last_updated"`
	Details      string          `json:"details"`
	RepositoryID uuid.NullUUID   `json:"repository_id"`
	Entity       Entities        `json:"entity"`
	RepoName     string          `json:"repo_name"`
	RepoOwner    string          `json:"repo_owner"`
	Provider     string          `json:"provider"`
	RuleTypeName string          `json:"rule_type_name"`
	RuleTypeID   uuid.UUID       `json:"rule_type_id"`
}

func (q *Queries) ListRuleEvaluationStatusByPolicyId(ctx context.Context, arg ListRuleEvaluationStatusByPolicyIdParams) ([]ListRuleEvaluationStatusByPolicyIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listRuleEvaluationStatusByPolicyId,
		arg.PolicyID,
		arg.EntityType,
		arg.EntityID,
		arg.RuleName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRuleEvaluationStatusByPolicyIdRow{}
	for rows.Next() {
		var i ListRuleEvaluationStatusByPolicyIdRow
		if err := rows.Scan(
			&i.EvalStatus,
			&i.LastUpdated,
			&i.Details,
			&i.RepositoryID,
			&i.Entity,
			&i.RepoName,
			&i.RepoOwner,
			&i.Provider,
			&i.RuleTypeName,
			&i.RuleTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRuleEvaluationStatusForRepository = `-- name: UpdateRuleEvaluationStatusForRepository :exec
UPDATE rule_evaluation_status 
    SET eval_status = $1, details = $2, last_updated = NOW()
    WHERE id = $3
`

type UpdateRuleEvaluationStatusForRepositoryParams struct {
	EvalStatus EvalStatusTypes `json:"eval_status"`
	Details    string          `json:"details"`
	ID         uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateRuleEvaluationStatusForRepository(ctx context.Context, arg UpdateRuleEvaluationStatusForRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, updateRuleEvaluationStatusForRepository, arg.EvalStatus, arg.Details, arg.ID)
	return err
}

const upsertRuleEvaluationStatus = `-- name: UpsertRuleEvaluationStatus :exec
INSERT INTO rule_evaluation_status (
    policy_id,
    repository_id,
    artifact_id,
    rule_type_id,
    entity,
    eval_status,
    details,
    last_updated
) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
ON CONFLICT(policy_id, repository_id, COALESCE(artifact_id, '00000000-0000-0000-0000-000000000000'::UUID), entity, rule_type_id) DO UPDATE SET
    eval_status = $6,
    details = $7,
    last_updated = NOW()
WHERE rule_evaluation_status.policy_id = $1
  AND rule_evaluation_status.repository_id = $2
  AND rule_evaluation_status.artifact_id IS NOT DISTINCT FROM $3
  AND rule_evaluation_status.rule_type_id = $4
  AND rule_evaluation_status.entity = $5
`

type UpsertRuleEvaluationStatusParams struct {
	PolicyID     uuid.UUID       `json:"policy_id"`
	RepositoryID uuid.NullUUID   `json:"repository_id"`
	ArtifactID   uuid.NullUUID   `json:"artifact_id"`
	RuleTypeID   uuid.UUID       `json:"rule_type_id"`
	Entity       Entities        `json:"entity"`
	EvalStatus   EvalStatusTypes `json:"eval_status"`
	Details      string          `json:"details"`
}

func (q *Queries) UpsertRuleEvaluationStatus(ctx context.Context, arg UpsertRuleEvaluationStatusParams) error {
	_, err := q.db.ExecContext(ctx, upsertRuleEvaluationStatus,
		arg.PolicyID,
		arg.RepositoryID,
		arg.ArtifactID,
		arg.RuleTypeID,
		arg.Entity,
		arg.EvalStatus,
		arg.Details,
	)
	return err
}
