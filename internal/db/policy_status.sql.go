// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: policy_status.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRuleEvaluationStatusForRepository = `-- name: CreateRuleEvaluationStatusForRepository :exec
INSERT INTO rule_evaluation_status (
    policy_id,
    repository_id,
    rule_type_id,
    entity,
    eval_status,
    eval_details,
    last_updated
) VALUES ($1, $2, $3, 'repository', $4, $5, NOW())
`

type CreateRuleEvaluationStatusForRepositoryParams struct {
	PolicyID     uuid.UUID       `json:"policy_id"`
	RepositoryID uuid.NullUUID   `json:"repository_id"`
	RuleTypeID   uuid.UUID       `json:"rule_type_id"`
	EvalStatus   EvalStatusTypes `json:"eval_status"`
	EvalDetails  string          `json:"eval_details"`
}

func (q *Queries) CreateRuleEvaluationStatusForRepository(ctx context.Context, arg CreateRuleEvaluationStatusForRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, createRuleEvaluationStatusForRepository,
		arg.PolicyID,
		arg.RepositoryID,
		arg.RuleTypeID,
		arg.EvalStatus,
		arg.EvalDetails,
	)
	return err
}

const getPolicyStatusByIdAndProject = `-- name: GetPolicyStatusByIdAndProject :one
SELECT p.id, p.name, ps.policy_status, ps.last_updated FROM policy_status ps
INNER JOIN policies p ON p.id = ps.policy_id
WHERE p.id = $1 AND p.project_id = $2
`

type GetPolicyStatusByIdAndProjectParams struct {
	ID        uuid.UUID `json:"id"`
	ProjectID uuid.UUID `json:"project_id"`
}

type GetPolicyStatusByIdAndProjectRow struct {
	ID           uuid.UUID       `json:"id"`
	Name         string          `json:"name"`
	PolicyStatus EvalStatusTypes `json:"policy_status"`
	LastUpdated  time.Time       `json:"last_updated"`
}

func (q *Queries) GetPolicyStatusByIdAndProject(ctx context.Context, arg GetPolicyStatusByIdAndProjectParams) (GetPolicyStatusByIdAndProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getPolicyStatusByIdAndProject, arg.ID, arg.ProjectID)
	var i GetPolicyStatusByIdAndProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PolicyStatus,
		&i.LastUpdated,
	)
	return i, err
}

const getPolicyStatusByNameAndProject = `-- name: GetPolicyStatusByNameAndProject :one
SELECT p.id, p.name, ps.policy_status, ps.last_updated FROM policy_status ps
INNER JOIN policies p ON p.id = ps.policy_id
WHERE p.name = $1 AND p.project_id = $2
`

type GetPolicyStatusByNameAndProjectParams struct {
	Name      string    `json:"name"`
	ProjectID uuid.UUID `json:"project_id"`
}

type GetPolicyStatusByNameAndProjectRow struct {
	ID           uuid.UUID       `json:"id"`
	Name         string          `json:"name"`
	PolicyStatus EvalStatusTypes `json:"policy_status"`
	LastUpdated  time.Time       `json:"last_updated"`
}

func (q *Queries) GetPolicyStatusByNameAndProject(ctx context.Context, arg GetPolicyStatusByNameAndProjectParams) (GetPolicyStatusByNameAndProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getPolicyStatusByNameAndProject, arg.Name, arg.ProjectID)
	var i GetPolicyStatusByNameAndProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PolicyStatus,
		&i.LastUpdated,
	)
	return i, err
}

const getPolicyStatusByProject = `-- name: GetPolicyStatusByProject :many
SELECT p.id, p.name, ps.policy_status, ps.last_updated FROM policy_status ps
INNER JOIN policies p ON p.id = ps.policy_id
WHERE p.project_id = $1
`

type GetPolicyStatusByProjectRow struct {
	ID           uuid.UUID       `json:"id"`
	Name         string          `json:"name"`
	PolicyStatus EvalStatusTypes `json:"policy_status"`
	LastUpdated  time.Time       `json:"last_updated"`
}

func (q *Queries) GetPolicyStatusByProject(ctx context.Context, projectID uuid.UUID) ([]GetPolicyStatusByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getPolicyStatusByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPolicyStatusByProjectRow{}
	for rows.Next() {
		var i GetPolicyStatusByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PolicyStatus,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRuleEvaluationStatusByPolicyId = `-- name: ListRuleEvaluationStatusByPolicyId :many
SELECT res.eval_status as eval_status, res.eval_last_updated as eval_last_updated, res.eval_details as eval_details, res.remediation_status as rem_status, res.remediation_details as rem_details, res.remediation_last_updated as rem_last_updated, res.repository_id as repository_id, res.entity as entity, repo.repo_name as repo_name, repo.repo_owner as repo_owner, repo.provider as provider, rt.name as rule_type_name, rt.id as rule_type_id
FROM rule_evaluation_status res
INNER JOIN repositories repo ON repo.id = res.repository_id
INNER JOIN rule_type rt ON rt.id = res.rule_type_id
WHERE res.policy_id = $1 AND
    (
        CASE
            WHEN $2::entities = 'repository' AND res.repository_id = $3::UUID THEN true
            WHEN $2::entities  = 'artifact' AND res.artifact_id = $3::UUID THEN true
            WHEN $3::UUID IS NULL THEN true
            ELSE false
        END
    ) AND (rt.name = $4 OR $4 IS NULL)
`

type ListRuleEvaluationStatusByPolicyIdParams struct {
	PolicyID   uuid.UUID      `json:"policy_id"`
	EntityType NullEntities   `json:"entity_type"`
	EntityID   uuid.NullUUID  `json:"entity_id"`
	RuleName   sql.NullString `json:"rule_name"`
}

type ListRuleEvaluationStatusByPolicyIdRow struct {
	EvalStatus      EvalStatusTypes        `json:"eval_status"`
	EvalLastUpdated time.Time              `json:"eval_last_updated"`
	EvalDetails     string                 `json:"eval_details"`
	RemStatus       RemediationStatusTypes `json:"rem_status"`
	RemDetails      string                 `json:"rem_details"`
	RemLastUpdated  sql.NullTime           `json:"rem_last_updated"`
	RepositoryID    uuid.NullUUID          `json:"repository_id"`
	Entity          Entities               `json:"entity"`
	RepoName        string                 `json:"repo_name"`
	RepoOwner       string                 `json:"repo_owner"`
	Provider        string                 `json:"provider"`
	RuleTypeName    string                 `json:"rule_type_name"`
	RuleTypeID      uuid.UUID              `json:"rule_type_id"`
}

func (q *Queries) ListRuleEvaluationStatusByPolicyId(ctx context.Context, arg ListRuleEvaluationStatusByPolicyIdParams) ([]ListRuleEvaluationStatusByPolicyIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listRuleEvaluationStatusByPolicyId,
		arg.PolicyID,
		arg.EntityType,
		arg.EntityID,
		arg.RuleName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRuleEvaluationStatusByPolicyIdRow{}
	for rows.Next() {
		var i ListRuleEvaluationStatusByPolicyIdRow
		if err := rows.Scan(
			&i.EvalStatus,
			&i.EvalLastUpdated,
			&i.EvalDetails,
			&i.RemStatus,
			&i.RemDetails,
			&i.RemLastUpdated,
			&i.RepositoryID,
			&i.Entity,
			&i.RepoName,
			&i.RepoOwner,
			&i.Provider,
			&i.RuleTypeName,
			&i.RuleTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRuleEvaluationStatusForRepository = `-- name: UpdateRuleEvaluationStatusForRepository :exec
UPDATE rule_evaluation_status 
    SET eval_status = $1, eval_details = $2, remediation_status = $3, remediation_details=$4, remediation_last_updated=$5, last_updated = NOW()
    WHERE id = $5
`

type UpdateRuleEvaluationStatusForRepositoryParams struct {
	EvalStatus             EvalStatusTypes        `json:"eval_status"`
	EvalDetails            string                 `json:"eval_details"`
	RemediationStatus      RemediationStatusTypes `json:"remediation_status"`
	RemediationDetails     string                 `json:"remediation_details"`
	RemediationLastUpdated sql.NullTime           `json:"remediation_last_updated"`
}

func (q *Queries) UpdateRuleEvaluationStatusForRepository(ctx context.Context, arg UpdateRuleEvaluationStatusForRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, updateRuleEvaluationStatusForRepository,
		arg.EvalStatus,
		arg.EvalDetails,
		arg.RemediationStatus,
		arg.RemediationDetails,
		arg.RemediationLastUpdated,
	)
	return err
}

const upsertRuleEvaluationStatus = `-- name: UpsertRuleEvaluationStatus :exec
INSERT INTO rule_evaluation_status (
    policy_id,
    repository_id,
    artifact_id,
    rule_type_id,
    entity,
    eval_status,
    eval_details,
    remediation_status,
    remediation_details,
    remediation_last_updated,
    eval_last_updated
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
ON CONFLICT(policy_id, repository_id, COALESCE(artifact_id, '00000000-0000-0000-0000-000000000000'::UUID), entity, rule_type_id) DO UPDATE SET
    eval_status = $6,
    eval_details = $7,
    remediation_status = $8,
    remediation_details = $9,
    remediation_last_updated = COALESCE($10, rule_evaluation_status.remediation_last_updated), -- don't overwrite timestamp already set with NULL
    eval_last_updated = NOW()
WHERE rule_evaluation_status.policy_id = $1
  AND rule_evaluation_status.repository_id = $2
  AND rule_evaluation_status.artifact_id IS NOT DISTINCT FROM $3
  AND rule_evaluation_status.rule_type_id = $4
  AND rule_evaluation_status.entity = $5
`

type UpsertRuleEvaluationStatusParams struct {
	PolicyID               uuid.UUID              `json:"policy_id"`
	RepositoryID           uuid.NullUUID          `json:"repository_id"`
	ArtifactID             uuid.NullUUID          `json:"artifact_id"`
	RuleTypeID             uuid.UUID              `json:"rule_type_id"`
	Entity                 Entities               `json:"entity"`
	EvalStatus             EvalStatusTypes        `json:"eval_status"`
	EvalDetails            string                 `json:"eval_details"`
	RemediationStatus      RemediationStatusTypes `json:"remediation_status"`
	RemediationDetails     string                 `json:"remediation_details"`
	RemediationLastUpdated sql.NullTime           `json:"remediation_last_updated"`
}

func (q *Queries) UpsertRuleEvaluationStatus(ctx context.Context, arg UpsertRuleEvaluationStatusParams) error {
	_, err := q.db.ExecContext(ctx, upsertRuleEvaluationStatus,
		arg.PolicyID,
		arg.RepositoryID,
		arg.ArtifactID,
		arg.RuleTypeID,
		arg.Entity,
		arg.EvalStatus,
		arg.EvalDetails,
		arg.RemediationStatus,
		arg.RemediationDetails,
		arg.RemediationLastUpdated,
	)
	return err
}
