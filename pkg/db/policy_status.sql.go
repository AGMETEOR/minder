// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: policy_status.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getPolicyStatusByGroup = `-- name: GetPolicyStatusByGroup :many
SELECT p.id, p.name, ps.policy_status, ps.last_updated FROM policy_status ps
INNER JOIN policies p ON p.id = ps.policy_id
WHERE p.group_id = $1
`

type GetPolicyStatusByGroupRow struct {
	ID           int32           `json:"id"`
	Name         string          `json:"name"`
	PolicyStatus EvalStatusTypes `json:"policy_status"`
	LastUpdated  time.Time       `json:"last_updated"`
}

func (q *Queries) GetPolicyStatusByGroup(ctx context.Context, groupID int32) ([]GetPolicyStatusByGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getPolicyStatusByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPolicyStatusByGroupRow{}
	for rows.Next() {
		var i GetPolicyStatusByGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PolicyStatus,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPolicyStatusByIdAndGroup = `-- name: GetPolicyStatusByIdAndGroup :one
SELECT p.id, p.name, ps.policy_status, ps.last_updated FROM policy_status ps
INNER JOIN policies p ON p.id = ps.policy_id
WHERE p.id = $1 AND p.group_id = $2
`

type GetPolicyStatusByIdAndGroupParams struct {
	ID      int32 `json:"id"`
	GroupID int32 `json:"group_id"`
}

type GetPolicyStatusByIdAndGroupRow struct {
	ID           int32           `json:"id"`
	Name         string          `json:"name"`
	PolicyStatus EvalStatusTypes `json:"policy_status"`
	LastUpdated  time.Time       `json:"last_updated"`
}

func (q *Queries) GetPolicyStatusByIdAndGroup(ctx context.Context, arg GetPolicyStatusByIdAndGroupParams) (GetPolicyStatusByIdAndGroupRow, error) {
	row := q.db.QueryRowContext(ctx, getPolicyStatusByIdAndGroup, arg.ID, arg.GroupID)
	var i GetPolicyStatusByIdAndGroupRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PolicyStatus,
		&i.LastUpdated,
	)
	return i, err
}

const listRuleEvaluationStatusForRepositoriesByPolicyId = `-- name: ListRuleEvaluationStatusForRepositoriesByPolicyId :many
SELECT res.eval_status, res.last_updated, res.repository_id, repo.repo_name, repo.repo_owner, repo.provider, rt.name, rt.id as rule_type_id
FROM rule_evaluation_status res
INNER JOIN repositories repo ON repo.id = res.repository_id
INNER JOIN rule_type rt ON rt.id = res.rule_type_id
WHERE res.entity = 'repository' AND res.policy_id = $1
`

type ListRuleEvaluationStatusForRepositoriesByPolicyIdRow struct {
	EvalStatus   EvalStatusTypes `json:"eval_status"`
	LastUpdated  time.Time       `json:"last_updated"`
	RepositoryID sql.NullInt32   `json:"repository_id"`
	RepoName     string          `json:"repo_name"`
	RepoOwner    string          `json:"repo_owner"`
	Provider     string          `json:"provider"`
	Name         string          `json:"name"`
	RuleTypeID   int32           `json:"rule_type_id"`
}

func (q *Queries) ListRuleEvaluationStatusForRepositoriesByPolicyId(ctx context.Context, policyID int32) ([]ListRuleEvaluationStatusForRepositoriesByPolicyIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listRuleEvaluationStatusForRepositoriesByPolicyId, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRuleEvaluationStatusForRepositoriesByPolicyIdRow{}
	for rows.Next() {
		var i ListRuleEvaluationStatusForRepositoriesByPolicyIdRow
		if err := rows.Scan(
			&i.EvalStatus,
			&i.LastUpdated,
			&i.RepositoryID,
			&i.RepoName,
			&i.RepoOwner,
			&i.Provider,
			&i.Name,
			&i.RuleTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRuleEvaluationStatusForRepositoryByPolicyId = `-- name: ListRuleEvaluationStatusForRepositoryByPolicyId :many
SELECT res.eval_status, res.last_updated, res.repository_id, repo.repo_name, repo.repo_owner, repo.provider, rt.name, rt.id as rule_type_id
FROM rule_evaluation_status res
INNER JOIN repositories repo ON repo.id = res.repository_id
INNER JOIN rule_type rt ON rt.id = res.rule_type_id
WHERE res.entity = 'repository' AND res.policy_id = $1 AND repo.id = $2
`

type ListRuleEvaluationStatusForRepositoryByPolicyIdParams struct {
	PolicyID int32 `json:"policy_id"`
	ID       int32 `json:"id"`
}

type ListRuleEvaluationStatusForRepositoryByPolicyIdRow struct {
	EvalStatus   EvalStatusTypes `json:"eval_status"`
	LastUpdated  time.Time       `json:"last_updated"`
	RepositoryID sql.NullInt32   `json:"repository_id"`
	RepoName     string          `json:"repo_name"`
	RepoOwner    string          `json:"repo_owner"`
	Provider     string          `json:"provider"`
	Name         string          `json:"name"`
	RuleTypeID   int32           `json:"rule_type_id"`
}

func (q *Queries) ListRuleEvaluationStatusForRepositoryByPolicyId(ctx context.Context, arg ListRuleEvaluationStatusForRepositoryByPolicyIdParams) ([]ListRuleEvaluationStatusForRepositoryByPolicyIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listRuleEvaluationStatusForRepositoryByPolicyId, arg.PolicyID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRuleEvaluationStatusForRepositoryByPolicyIdRow{}
	for rows.Next() {
		var i ListRuleEvaluationStatusForRepositoryByPolicyIdRow
		if err := rows.Scan(
			&i.EvalStatus,
			&i.LastUpdated,
			&i.RepositoryID,
			&i.RepoName,
			&i.RepoOwner,
			&i.Provider,
			&i.Name,
			&i.RuleTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePolicyStatus = `-- name: UpdatePolicyStatus :exec
INSERT INTO policy_status (policy_id, policy_status, last_updated) VALUES ($1, $2, NOW())
ON CONFLICT (policy_id) DO UPDATE SET policy_status = $2, last_updated = NOW()
`

type UpdatePolicyStatusParams struct {
	PolicyID     int32           `json:"policy_id"`
	PolicyStatus EvalStatusTypes `json:"policy_status"`
}

func (q *Queries) UpdatePolicyStatus(ctx context.Context, arg UpdatePolicyStatusParams) error {
	_, err := q.db.ExecContext(ctx, updatePolicyStatus, arg.PolicyID, arg.PolicyStatus)
	return err
}
